#!/bin/bash

sourcing our current rc.conf requires this to be a bash script
. @RCLIBDIR@/functions
. @RCDIR@/rc.conf

CGROUP_OPTS=nodev,noexec,nosuid
HAVE_CONTROLLER1_GROUPS=${HAVE_CONTROLLER1_GROUPS:-true}
CGROUP_MODE=${CGROUP_MODE:-hybrid}
CGROUP_CONTROLLERS=""

cgroup2_find_path(){
    if grep -qw cgroup2 /proc/filesystems; then
        case "${CGROUP_MODE}" in
            hybrid) printf "/sys/fs/cgroup/unified" ;;
            unified) printf "/sys/fs/cgroup" ;;
        esac
    fi
    return 0
}

cgroup1_base(){
    grep -qw cgroup /proc/filesystems || return 0
    if ! mountpoint -q /sys/fs/cgroup; then
        local opts="${CGROUP_OPTS},mode=755,size=${rc_cgroupsize:-10m}"
        mount -n -t tmpfs -o "${opts}" cgroup_root /sys/fs/cgroup
    fi

    if ! mountpoint -q /sys/fs/cgroup/openrc; then
        local agent="@RCLIBDIR@/cgroup-release-agent"
        mkdir /sys/fs/cgroup/openrc
        mount -n -t cgroup -o none,${CGROUP_OPTS},name=openrc,release_agent="$agent" openrc /sys/fs/cgroup/openrc
        printf 1 > /sys/fs/cgroup/openrc/notify_on_release
    fi
    return 0
}

cgroup1_controllers(){
...skipping...
    return 0
}

cgroups_unified(){
    cgroup2_base
    cgroup2_controllers
    return 0
}

mount_cgroups(){
    case "${CGROUP_MODE}" in
        hybrid) cgroups_hybrid ;;
        legacy) cgroups_legacy ;;
        unified) cgroups_unified ;;
    esac
    return 0
}

mount_cgs(){
    if [ -d /sys/fs/cgroup ];then
        mount_cgroups
        return 0
    fi
    return 1
}

case "$1" in
    start)
        stat_busy "Mounting cgroups filesystem"
        mount_cgs || stat_die cgroups
        add_daemon cgroups
        stat_done cgroups
        ;;
    *)
        echo "usage: $0 {start}"
        exit 1
        ;;
esac
