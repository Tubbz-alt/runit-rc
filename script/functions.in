#!/bin/bash
# rc functions
#

# sanitize PATH (will be overridden later when /etc/profile is sourced but is useful for udev)
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

. /etc/profile.d/locale.sh

# width:
calc_columns () {
    STAT_COL=80
    if [[ ! -t 1 ]]; then
        USECOLOR=""
    elif [[ -t 0 ]]; then
        # stty will fail when stdin isn't a terminal
        STAT_COL=$(stty size)
        # stty gives "rows cols"; strip the rows number, we just want columns
        STAT_COL=${STAT_COL##* }
    elif tput cols &>/dev/null; then
        # is /usr/share/terminfo already mounted, and TERM recognized?
        STAT_COL=$(tput cols)
    fi
    if (( STAT_COL == 0 )); then
        # if output was 0 (serial console), set default width to 80
        STAT_COL=80
        USECOLOR=""
    fi

    # we use 13 characters for our own stuff
    STAT_COL=$(( STAT_COL - 13 ))

    if [[ -t 1 ]]; then
        SAVE_POSITION="\e[s"
        RESTORE_POSITION="\e[u"
        DEL_TEXT="\e[$(( STAT_COL + 4 ))G"
    else
        SAVE_POSITION=""
        RESTORE_POSITION=""
        DEL_TEXT=""
    fi
}

runit_sv_available()
{
	[[ -d @RUNITDIR@/sv/$1 ]]
}

runit_sv_enabled()
{
	[[ -h @RUNITRUNDIR@/service/"$1" ]]
}

rc_sv_available()
{
	[[ -x @RCSVDIR@/"$1" ]]
}

rc_sv_enabled()
{
	[[ -h @RCENABLEDDIR@/"$1" ]]
}

rc_sv_up()
{
	[[ -f @RCRUNDIR@/active/$1 ]]
}

ck_service()
{
	if runit_sv_available "$1"; then
		runit_sv_up "$1"
	else
		rc_sv_up "$1"
	fi
}

ck_status()
{
	if runit_sv_enabled "$1"; then
		if runit_sv_up "$1"; then
			msg_ok "$1: up, pid: $(cat @RUNITRUNDIR@/service/$1/supervise/pid)"
		else
			msg_error "$1: down"
		fi
	elif rc_sv_enabled "$1"; then
		msg_ok "$1: rc service enabled"
	elif runit_sv_available "$1"; then
		msg_error "$1: runit service is not enabled"
	elif rc_sv_available "$1"; then
		msg_error "$1: rc service is not enabled"
	else
		msg_error "$1 is not an existing runit or rc service"
	fi
}

service_status()
{
	if ck_service "$1"; then
		STATUS="${C_DONE} up "
	else
		STATUS="${C_FAIL}down"
	fi
	if runit_sv_enabled "$1"; then
		ENABLED_STATUS="${C_MAIN}*"
	elif rc_sv_enabled "$1"; then
		ENABLED_STATUS="${C_MAIN}*"
	else
		ENABLED_STATUS=" "
	fi
	printf "${C_OTHER}[$STATUS${C_OTHER}]${C_CLEAR} ${C_OTHER}[$ENABLED_STATUS${C_OTHER}]${C_CLEAR} $1 \n"
}

runit_sv_up()
{
	runit_sv_enabled "$1" && [[ "$(cat @RUNITRUNDIR@/service/$1/supervise/stat 2>/dev/null)" == "run" ]] && [[ -s @RUNITRUNDIR@/service/$1/supervise/pid ]]
}

enable_runit_sv()
{
	ln -sf @RUNITDIR@/sv/"$1" @RUNITRUNDIR@/service/
	# this will make sure the service is enabled if ./down exists
	runit_send_signal "u" "$1"
	ck_status "$1"
}

disable_runit_sv()
{
	rm -f @RUNITRUNDIR@/service/"$1"
	msg_ok "$1: disabled"
}

enable_rc_sv()
{
	ln -sf @RCSVDIR@/"$1" @RCENABLEDDIR@/
	@RCENABLEDDIR@/"$1" start
}

disable_rc_sv()
{
	@RCENABLEDDIR@/"$1" stop
	rm -f @RCENABLEDDIR@/"$1"
}

list_rc_services() {
	echo "rc services: "
	cd @RCSVDIR@ || msg_error "error!"
	for d in *; do
		have_service "$d" && daemons+=("$d")
		service_status "$d"
	done
}

list_runit_services() {
	echo "runit services: "
	cd @RUNITDIR@/sv || return
	for daemon in *; do
		service_status "$daemon"
	done
}

runit_send_signal() {
	if runit_sv_enabled "$2"; then
		printf "%s" "$1" > "@RUNITRUNDIR@/service/$2/supervise/control"
	else
		ck_status "$2"
		return 100
	fi
}

have_service()
{
	[[ -x @RCSVDIR@/$1 ]]
}

### Long functions to be run in stages

# Check local filesystems
fsck_all() {
    if [[ -f /forcefsck ]] || in_array forcefsck $(< /proc/cmdline); then
        FORCEFSCK="-f"
    elif [[ -f /fastboot ]] || in_array fastboot $(< /proc/cmdline); then
        return 0
    elif [[ -e /run/initramfs/root-fsck ]]; then
        IGNORE_MOUNTED="-M"
    fi

    fsck -A -T -C${FSCK_FD} -a -t no${NETFS//,/,no},noopts=_netdev ${IGNORE_MOUNTED} -- ${FORCEFSCK}
}

# Single-user login and/or automatic reboot after fsck (if needed)
fsck_reboot() {
    # $1 = exit code returned by fsck
    # Ignore conditions 'FS errors corrected' and 'Cancelled by the user'
    (( ($1 | 33) == 33 )) && return 0
    if (( $1 & 2 )); then
        echo
        echo "********************** REBOOT REQUIRED *********************"
        echo "*                                                          *"
        echo "* The system will be rebooted automatically in 15 seconds. *"
        echo "*                                                          *"
        echo "************************************************************"
        echo
        sleep 15
    else
        echo
        echo "*****************  FILESYSTEM CHECK FAILED  ****************"
        echo "*                                                          *"
        echo "*  Please repair manually and reboot. Note that the root   *"
        echo "*  file system is currently mounted read-only. To remount  *"
        echo "*  it read-write, type: mount -o remount,rw /              *"
        echo "*  When you exit the maintenance shell, the system will    *"
        echo "*  reboot automatically.                                   *"
        echo "*                                                          *"
        echo "************************************************************"
        echo
        emergency_shell
    fi
    echo "Automatic reboot in progress..."
    umount -a
    mount -o remount,ro /
    reboot -f
    exit 0
}

do_fsck(){
    if [[ -x $(type -P fsck) ]]; then
        fsck_all >|"${FSCK_OUT:-/dev/stdout}" 2>|"${FSCK_ERR:-/dev/stdout}"
        declare -r fsckret=$?
    else
        declare -r fsckret=0
    fi
    fsck_reboot $fsckret
}

CGROUP_OPTS=nodev,noexec,nosuid
HAVE_CONTROLLER1_GROUPS=${HAVE_CONTROLLER1_GROUPS:-true}
CGROUP_MODE=${CGROUP_MODE:-hybrid}
CGROUP_CONTROLLERS=""

cgroup2_find_path(){
    if grep -qw cgroup2 /proc/filesystems; then
        case "${CGROUP_MODE}" in
            hybrid) printf "/sys/fs/cgroup/unified" ;;
            unified) printf "/sys/fs/cgroup" ;;
        esac
    fi
    return 0
}

cgroup1_base(){
    grep -qw cgroup /proc/filesystems || return 0
    if ! mountpoint -q /sys/fs/cgroup; then
        local opts="${CGROUP_OPTS},mode=755,size=${rc_cgroupsize:-10m}"
        mount -n -t tmpfs -o "${opts}" cgroup_root /sys/fs/cgroup
    fi

    if ! mountpoint -q /sys/fs/cgroup/openrc; then
        local agent="@RCLIBDIR@/cgroup-release-agent"
        mkdir /sys/fs/cgroup/openrc
        mount -n -t cgroup -o none,${CGROUP_OPTS},name=openrc,release_agent="$agent" openrc /sys/fs/cgroup/openrc
        printf 1 > /sys/fs/cgroup/openrc/notify_on_release
    fi
    return 0
}

cgroup1_controllers(){
    ${HAVE_CONTROLLER1_GROUPS} && [ -e /proc/cgroups ]  && grep -qw cgroup /proc/filesystems || return 0
    while read -r name _ _ enabled _; do
        case "${enabled}" in
            1)	if mountpoint -q "/sys/fs/cgroup/${name}";then continue;fi
                local x
                for x in $CGROUP_CONTROLLERS; do
                    [ "${name}" = "blkio" ] && [ "${x}" = "io" ] &&
                        continue 2
                    [ "${name}" = "${x}" ] &&
                    continue 2
                done
                mkdir "/sys/fs/cgroup/${name}"
                mount -n -t cgroup -o "${CGROUP_OPTS},${name}" "${name}" "/sys/fs/cgroup/${name}"
            ;;
        esac
    done < /proc/cgroups
    return 0
}

cgroup2_base(){
    grep -qw cgroup2 /proc/filesystems || return 0
    local base
    base="$(cgroup2_find_path)"
    mkdir -p "${base}"
    mount -t cgroup2 none -o "${CGROUP_OPTS},nsdelegate" "${base}" 2> /dev/null ||
        mount -t cgroup2 none -o "${CGROUP_OPTS}" "${base}"
    return 0
}

cgroup2_controllers(){
    grep -qw cgroup2 /proc/filesystems || return 0
    local active cgroup_path x y
    cgroup_path="$(cgroup2_find_path)"
    [ -z "${cgroup_path}" ] && return 0
    [ -e "${cgroup_path}/cgroup.controllers" ] && read -r active < "${cgroup_path}/cgroup.controllers"
    for x in ${CGROUP_CONTROLLERS}; do
        for y in ${active}; do
            [ "$x" = "$y" ] && [ -e "${cgroup_path}/cgroup.subtree_control" ] &&
            echo "+${x}"  > "${cgroup_path}/cgroup.subtree_control"
        done
    done
    return 0
}

cgroups_hybrid(){
    cgroup1_base
    cgroup2_base
    cgroup2_controllers
    cgroup1_controllers
    return 0
}

cgroups_legacy(){
    cgroup1_base
    cgroup1_controllers
    return 0
}

cgroups_unified(){
    cgroup2_base
    cgroup2_controllers
    return 0
}

mount_cgroups(){
    case "${CGROUP_MODE}" in
        hybrid) cgroups_hybrid ;;
        legacy) cgroups_legacy ;;
        unified) cgroups_unified ;;
    esac
    return 0
}

mount_cgs(){
    if [ -d /sys/fs/cgroup ]; then
        mount_cgroups
        return 0
    fi
}

do_unlock_device() {
	# $1 = requested name
	# $2 = source device
	# $3 = password
	# $4 = options
	local open=create a=$1 b=$2 failed=0 opts
	# Ordering of options is different if you are using LUKS vs. not.
	# Use ugly swizzling to deal with it.
	# isLuks only gives an exit code but no output to stdout or stderr.
	if cryptsetup isLuks "$2" 2>/dev/null; then
		open=luksOpen
		a=$2
		b=$1
	else
		printhl "Non-LUKS partitions are not supported at the moment."
		continue
	fi
	if [[ $4 ]]; then
		for i in ${4//,/ }; do
			case $i in
				"discard") opts+="--allow-discard" ;;
				"readonly"|"read-only") opts+="--readonly" ;;
				"tries"*) opts+="-T ${i##*=}" ;;
				"keyfile-size"*) opts+="-l ${i##*=}" ;;
				"keyfile-offset"*) opts+="--keyfile-offset ${i##*=}" ;;
				"key-slot"*) opts+="-S ${i##*=}" ;;
				*)
					printhl "The option is not currently supported at the moment."
					printhl "Please add an issue to https://github.com/artix-linux/runit-rc"
					continue
				;;
			esac
		done
	fi
	case $3 in
		/dev*)
			local ckdev=${3%%:*}
			local cka=${3#*:}
			local ckb=${cka#*:}
			local cka=${cka%:*}
			local ckfile=/dev/ckfile
			local ckdir=/dev/ckdir
			case ${cka} in
				*[!0-9]*)
					# Use a file on the device
					# cka is not numeric: cka=filesystem, ckb=path
					mkdir ${ckdir}
					mount -r -t ${cka} ${ckdev} ${ckdir}
					dd if=${ckdir}/${ckb} of=${ckfile} >/dev/null 2>&1
					umount ${ckdir}
					rmdir ${ckdir};;
				*)
					# Read raw data from the block device
					# cka is numeric: cka=offset, ckb=length
					dd if=${ckdev} of=${ckfile} bs=1 skip=${cka} count=${ckb} >/dev/null 2>&1;;
			esac
			cryptsetup -d ${ckfile} $opts $open "$a" "$b" >/dev/null
			dd if=/dev/urandom of=${ckfile} bs=1 count=$(stat -c %s ${ckfile}) conv=notrunc >/dev/null 2>&1
			rm ${ckfile};;
		/*)
			cryptsetup -d "$3" $opts $open "$a" "$b" >/dev/null;;
		"none" | "")
			cryptsetup $opts $open "$a" "$b" >/dev/null;;
	esac
	return $?
}

do_unlock() {
	local name=$1 device=$2 password=$3 options=$4

	printf "${C_MAIN}Unlocking $1${C_CLEAR}\n"

	if [[ ${options:0:2} =~ -. ]]; then
		do_unlock_device "$name" "$device" "$password" "$options"
		return $?
	fi

	do_unlock_device "$name" "$device" "$password" "$options"
	failed=$?
	if (( $failed )); then
		printf "${C_FAIL}Unlocking of $1 failed.${C_CLEAR}\n"
	fi
	return $?
}

do_lock() {
	#status "Detaching encrypted device ${1}"
	cryptsetup luksClose "$1" >/dev/null
}

read_crypttab() {
	# $1 = function to call with the split out line from the crypttab
	local line nspo failed=0
	while read line <&3; do
		[[ $line && $line != '#'* ]] || continue
		eval nspo=("${line%#*}")
		if $1 "${nspo[0]}" "${nspo[1]}" "${nspo[2]}" "${nspo[*]:3}"; then
			crypto_unlocked=1
		else
			failed=1
		fi
	done 3< /etc/crypttab
	return $failed
}

### End

### Begin: Oneshot services handling, rc-style.
function_exists()
{
	declare -f -F "$1" > /dev/null
	local ret=$?
	return $ret
}

start()
{
	local RC_SVNAME="$(basename $0)"
	if function_exists do_prestart; then
		msg "$RC_SVNAME: running prestart"
		do_prestart
		local ret=$?
		if [ $ret -gt 0 ]; then
			msg_error "$RC_SVNAME: prestart failed"
			return $ret
		fi
	fi

	msg "$RC_SVNAME: starting"
	do_start
	ret=$?
	if [ $ret -gt 0 ]; then
		msg_error "$RC_SVNAME: failed to start"
		return $ret
	else
		add_daemon "$RC_SVNAME"
		msg_ok "$RC_SVNAME: successfully activated"
	fi

	if function_exists do_poststart; then
		msg "$RC_SVNAME: running poststart"
		do_poststart
		if [ $ret -gt 0 ]; then
			msg_error "$RC_SVNAME: poststart failed"
			msg "$RC_SVNAME: stopping"
			do_stop
			rm_daemon "$1"
			return $ret
		fi
	fi
}

stop()
{
	if function_exists do_prestop; then
		msg "$RC_SVNAME: running prestop"
		do_prestop
		local ret=$?
		if [ $ret -gt 0 ]; then
			msg_error "$RC_SVNAME: prestop failed"
			return $ret
		fi
	fi
	do_stop
	rm_daemon "$1"
}

run_rc_command()
{
	eval "$1"
}

emergency_shell()
{
	msg_error "Cannot continue due to errors above, starting emergency shell."
	msg "When ready, type exit or Control+D to continue booting."
	sulogin -p
}

deltext() {
    printf "${DEL_TEXT}"
}

printhl() {
    printf "${C_OTHER}${PREFIX_HL} ${C_H1}${1}${C_CLEAR} \n"
}

printsep() {
    printf "\n${C_SEPARATOR}   ------------------------------\n"
}

msg() {
	printf "${C_OTHER}${PREFIX_REG} ${C_MAIN}${1}${C_CLEAR}\n"
}

msg_ok() {
	printf "${C_DONE}${PREFIX_REG} ${C_MAIN}${1}${C_CLEAR}\n"
}

msg_warn() {
	printf "${C_WARN}${PREFIX_REG} ${C_MAIN}${1}${C_CLEAR}\n"
}

msg_error() {
	printf "${C_FAIL}${PREFIX_REG} ${C_MAIN}${1}${C_CLEAR}\n"
}

add_daemon() {
	[[ -d @RCRUNDIR@/active ]] || mkdir -p @RCRUNDIR@/active
	touch @RCRUNDIR@/active/"$1"
}

rm_daemon() {
	rm -f @RCRUNDIR@/active/"$1"
}

#  usage : in_array( $needle, $haystack )
# return : 0 - found
#          1 - not found
in_array() {
    local needle=$1; shift
    local item
    for item; do
        [[ $item = "${needle}" ]] && return 0
    done
    return 1 # Not Found
}

print_welcome() {
    # see os-release(5)
    . /usr/lib/os-release

    echo " "
    printhl "${PRETTY_NAME}\n"
    printhl "${C_H2}${HOME_URL}"
    printsep
}

print_leave(){
    # avoid staircase effect
    stty onlcr
    echo " "
    printhl "Shutting down\n"
    echo " "
}

run_sysinit(){
    # Prints distro name and URL
    print_welcome
    calc_columns

    for stage1 in ${RC_STAGE1[@]};do
		[[ -x stage1 && -r stage1 ]] && . stage1
    done
}

run_shutdown(){
    print_leave

    for stage3 in ${RC_STAGE3[@]};do
		[[ -x stage3 && -r stage3 ]] && . stage3
    done
}

# if [[ $1 == "start" ]]; then
# 	if [[ $STARTING ]]; then
# 		echo "A daemon is starting another daemon; this is unlikely to work as intended."
# 	else
# 		export STARTING=1
# 	fi
# fi

calc_columns

# disable colors on broken terminals
TERM_COLORS=$(tput colors 2>/dev/null)
if (( $? != 3 )); then
    case $TERM_COLORS in
        *[!0-9]*) USECOLOR="";;
        [0-7])    USECOLOR="";;
        '')       USECOLOR="";;
    esac
fi
unset TERM_COLORS

# Filesystem functions
# These can be overridden/reused for customizations like shutdown/loop-fsck.
NETFS="nfs,nfs4,smbfs,cifs,codafs,ncpfs,shfs,fuse,fuseblk,glusterfs,davfs,fuse.glusterfs"

# set colors
# set colors
if [[ $USECOLOR != [nN][oO] ]]; then
    if tput setaf 0 &>/dev/null; then
        C_CLEAR=$(tput sgr0)                 # clear text
        C_MAIN=${C_CLEAR}$(tput bold)        # main text
        C_OTHER=${C_MAIN}$(tput setaf 4)     # prefix & brackets
        C_SEPARATOR=${C_MAIN}$(tput setaf 0) # separator
        C_BUSY=${C_CLEAR}$(tput setaf 6)     # busy
        C_FAIL=${C_MAIN}$(tput setaf 1)      # failed
        C_WARN=${C_MAIN}$(tput setaf 3)      # warning
        C_DONE=${C_MAIN}$(tput setaf 2)      # completed
        C_START=${C_MAIN}$(tput setaf 2)     # started
        C_H1=${C_MAIN}                       # highlight text 1
        C_H2=${C_MAIN}$(tput setaf 6)        # highlight text 2
    else
        C_CLEAR="\e[m"          # clear text
        C_MAIN="\e[;1m"         # main text
        C_OTHER="\e[1;34m"      # prefix & brackets
        C_SEPARATOR="\e[1;30m"  # separator
        C_BUSY="\e[;36m"        # busy
        C_FAIL="\e[1;35m"       # failed
        C_DONE=${C_MAIN}        # completed
        C_STOP="\e[1;31m"       # backgrounded
        C_START="\e[1;32m"    # started
        C_H1=${C_MAIN}          # highlight text 1
        C_H2="\e[1;36m"         # highlight text 2
    fi
fi

# prefixes:

PREFIX_REG="::"
PREFIX_HL=" >"

RC_SYSINIT=$(ls @RCLIBDIR@/stage1)
RC_SHUTDOWN=$(ls @RCLIBDIR@/stage3)
